from __future__ import annotations

import time
from typing import Dict, Tuple, List

import numpy as np

from core.general_utils import effective_capacity, scalarize_vector, vector_fits, residual_vector
from core.models import AssignmentState, Instance
from offline.offline_heuristics.core import HeuristicSolutionInfo


class CostAwareBestFitDecreasing:
    """
    Greedy offline heuristic that sorts items by volume (descending) and assigns
    each to the feasible bin with the lowest assignment cost. Ties on cost are
    broken by the smallest residual capacity to avoid fragmentation.
    """

    def __init__(self, cfg) -> None:
        self.cfg = cfg

    def solve(self, inst: Instance) -> Tuple[AssignmentState, HeuristicSolutionInfo]:
        start_time = time.perf_counter()

        size_key = self.cfg.heuristics.size_key
        items_sorted: List[Tuple[int, np.ndarray]] = sorted(
            ((idx, item.volume) for idx, item in enumerate(inst.offline_items)),
            key=lambda pair: scalarize_vector(pair[1], size_key),
            reverse=True,
        )

        regular_bins = len(inst.bins)
        fallback_idx = regular_bins
        dims = inst.bins[0].capacity.shape[0] if inst.bins else 1
        loads = np.zeros((regular_bins + 1, dims))
        assigned_bin: Dict[int, int] = {}

        eff_caps = [
            effective_capacity(
                bin_spec.capacity,
                self.cfg.slack.enforce_slack,
                self.cfg.slack.fraction,
            )
            for bin_spec in inst.bins
        ]

        for item_idx, volume in items_sorted:
            best_bin = None
            best_cost = float("inf")
            best_residual = float("inf")

            for bin_idx in range(regular_bins):
                if inst.feasible.feasible[item_idx, bin_idx] != 1:
                    continue
                if not vector_fits(loads[bin_idx], volume, eff_caps[bin_idx], 1e-9):
                    continue
                cost = float(inst.costs.assign[item_idx, bin_idx])
                residual = residual_vector(loads[bin_idx], volume, eff_caps[bin_idx])
                residual_score = scalarize_vector(residual, self.cfg.heuristics.residual_scalarization)
                if (
                    cost < best_cost - 1e-9
                    or (abs(cost - best_cost) <= 1e-9 and residual_score < best_residual)
                ):
                    best_cost = cost
                    best_residual = residual_score
                    best_bin = bin_idx

            if best_bin is not None:
                loads[best_bin] += volume
                assigned_bin[item_idx] = best_bin
                continue

            if (
                self.cfg.problem.fallback_is_enabled
                and inst.feasible.feasible[item_idx, fallback_idx] == 1
            ):
                loads[fallback_idx] += volume
                assigned_bin[item_idx] = fallback_idx
                continue

            raise ValueError(f"Item {item_idx} cannot be assigned to any feasible bin.")

        runtime = time.perf_counter() - start_time
        obj_value = self._calculate_objective(assigned_bin, inst)

        state = AssignmentState(
            load=loads,
            assigned_bin=assigned_bin,
            offline_evicted=set(),
        )
        utilization = float(
            np.mean(
                [
                    np.max(loads[i] / inst.bins[i].capacity)
                    for i in range(len(inst.bins))
                ]
            )
        )

        info = HeuristicSolutionInfo(
            algorithm="CostAwareBestFitDecreasing",
            runtime=runtime,
            obj_value=obj_value,
            feasible=True,
            items_in_fallback=sum(
                1 for bin_id in assigned_bin.values() if bin_id == fallback_idx
            ),
            utilization=utilization,
        )
        return state, info

    def _calculate_objective(
        self, assigned_bin: Dict[int, int], inst: Instance
    ) -> float:
        total_cost = 0.0
        fallback_idx = len(inst.bins)
        for item_idx, bin_idx in assigned_bin.items():
            if bin_idx < fallback_idx:
                total_cost += float(inst.costs.assign[item_idx, bin_idx])
            else:
                total_cost += inst.costs.huge_fallback
        return total_cost
